default namespace = "http://www.tei-c.org/ns/1.0"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2018-12-11T19:50:46Z. .
# TEI Edition: Version 2.8.0. Last updated on
#	6th April 2015, revision 13197
# TEI Edition Location: http://www.tei-c.org/Vault/P5/Version 2.8.0/
#

#
macro.paraContent =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.global
   | lg
   | l)*
macro.phraseSeq = (text | model.gLike | model.phrase | model.global)*
macro.specialPara =
  (text
   | model.gLike
   | model.phrase
   | model.inter
   | model.divPart
   | model.global)*
macro.xtext = (text | model.gLike)*
data.certainty = "high" | "medium" | "low" | "unknown"
data.probability = xsd:double { minInclusive = "0" maxInclusive = "1" }
data.numeric =
  xsd:double
  | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
  | xsd:decimal
data.count = xsd:nonNegativeInteger
data.temporal.w3c =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
data.xTruthValue = xsd:boolean | "unknown" | "inapplicable"
data.language = xsd:language | ""
data.pointer = xsd:anyURI
data.word = xsd:token { pattern = "(\p{L}|\p{N}|\p{P}|\p{S})+" }
data.text = xsd:string
data.name = xsd:Name
data.enumerated = data.word
data.temporal.iso =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
att.canonical.attributes =
  att.canonical.attribute.key, att.canonical.attribute.ref
att.canonical.attribute.key =
  
  ## provides an externally-defined means of identifying the entity (or entities) being named, using a coded value of some kind.
  attribute key { data.text }?
att.canonical.attribute.ref =
  
  ## (reference) provides an explicit means of locating a full definition for the entity being named by means of one or more URIs.
  attribute ref {
    list { data.pointer+ }
  }?
att.ranging.attributes =
  att.ranging.attribute.atLeast,
  att.ranging.attribute.atMost,
  att.ranging.attribute.min,
  att.ranging.attribute.max,
  att.ranging.attribute.confidence
att.ranging.attribute.atLeast =
  
  ## gives a minimum estimated value for the approximate measurement.
  attribute atLeast { data.numeric }?
att.ranging.attribute.atMost =
  
  ## gives a maximum estimated value for the approximate measurement.
  attribute atMost { data.numeric }?
att.ranging.attribute.min =
  
  ## where the measurement summarizes more than one observation or a range, supplies the minimum value observed.
  attribute min { data.numeric }?
att.ranging.attribute.max =
  
  ## where the measurement summarizes more than one observation or a range, supplies the maximum value observed.
  attribute max { data.numeric }?
att.ranging.attribute.confidence =
  
  ## specifies the degree of statistical confidence (between zero and one) that a value falls within the range specified by min and max, or the proportion of observed values that fall within that range.
  attribute confidence { data.probability }?
att.dimensions.attributes =
  att.ranging.attributes, att.dimensions.attribute.unit
att.dimensions.attribute.unit =
  
  ## names the unit used for the measurement
  ## Suggested values include: 1] cm(centimetres) ; 2] mm(millimetres) ; 3] in(inches) ; 4] lines; 5] chars(characters) 
  attribute unit {
    
    ## (centimetres) 
    "cm"
    | 
      ## (millimetres) 
      "mm"
    | 
      ## (inches) 
      "in"
    | 
      ## lines of text
      "lines"
    | 
      ## (characters) characters of text
      "chars"
    | xsd:Name
  }?
att.cReferencing.attributes = att.cReferencing.attribute.cRef
att.cReferencing.attribute.cRef =
  
  ## (canonical reference) specifies the destination of the pointer by supplying a canonical reference expressed using the scheme defined in a refsDecl element in the TEI header
  attribute cRef { data.text }?
att.datable.w3c.attributes =
  att.datable.w3c.attribute.notBefore,
  att.datable.w3c.attribute.notAfter
att.datable.w3c.attribute.notBefore =
  
  ## specifies the earliest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notBefore { data.temporal.w3c }?
att.datable.w3c.attribute.notAfter =
  
  ## specifies the latest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notAfter { data.temporal.w3c }?
att.datable.attributes =
  att.datable.w3c.attributes,
  att.datable.iso.attributes,
  att.datable.custom.attributes
att.declarable.attributes = att.declarable.attribute.default
att.declarable.attribute.default =
  
  ## indicates whether or not this element is selected by default when its parent is selected.
  [ a:defaultValue = "false" ]
  attribute default {
    
    ## This element is selected if its parent is selected
    "true"
    | 
      ## This element can only be selected explicitly, unless it is the only one of its kind, in which case it is selected if its parent is selected.
      "false"
  }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies one or more declarable elements within the header, which are understood to apply to the element bearing this attribute and its content.
  attribute decls {
    list { data.pointer+ }
  }?
att.fragmentable.attributes = att.fragmentable.attribute.part
att.fragmentable.attribute.part =
  
  ## specifies whether or not its parent element is fragmented in some way, typically by some other overlapping structure: for example a speech which is divided between two or more verse stanzas, a paragraph which is split across a page division, a verse line which is divided between two speakers.
  [ a:defaultValue = "N" ]
  attribute part {
    
    ## (yes) the element is fragmented in some (unspecified) respect
    "Y"
    | 
      ## (no) either the element is not fragmented, or no claim is made as to its completeness.
      "N"
    | 
      ## (initial) this is the initial part of a fragmented element
      "I"
    | 
      ## (medial) this is a medial part of a fragmented element
      "M"
    | 
      ## (final) this is the final part of a fragmented element
      "F"
  }?
att.divLike.attributes = att.fragmentable.attributes
att.docStatus.attributes = att.docStatus.attribute.status
att.docStatus.attribute.status =
  
  ## describes the status of a document either currently or, when associated with a dated element, at the time indicated.
  ## Sample values include: 1] approved; 2] candidate; 3] cleared; 4] deprecated; 5] draft; 6] embargoed; 7] expired; 8] frozen; 9] galley; 10] proposed; 11] published; 12] recommendation; 13] submitted; 14] unfinished; 15] withdrawn
  [ a:defaultValue = "draft" ] attribute status { data.enumerated }?
att.global.responsibility.attributes =
  att.global.responsibility.attribute.cert,
  att.global.responsibility.attribute.resp
att.global.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert { data.certainty }?
att.global.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an editor or transcriber.
  attribute resp {
    list { data.pointer+ }
  }?
att.editLike.attributes =
  att.dimensions.attributes,
  att.source.attributes,
  att.editLike.attribute.evidence,
  att.editLike.attribute.instant
att.editLike.attribute.evidence =
  
  ## indicates the nature of the evidence supporting the reliability or accuracy of the intervention or interpretation.
  ## Suggested values include: 1] internal; 2] external; 3] conjecture
  attribute evidence {
    list {
      (
       ## there is internal evidence to support the intervention.
       "internal"
       | 
         ## there is external evidence to support the intervention.
         "external"
       | 
         ## the intervention or interpretation has been made by the editor, cataloguer, or scholar on the basis of their expertise.
         "conjecture"
       | xsd:Name)+
    }
  }?
att.editLike.attribute.instant =
  
  ## indicates whether this is an instant revision or not.
  [ a:defaultValue = "false" ] attribute instant { data.xTruthValue }?
att.global.rendition.attributes =
  att.global.rendition.attribute.rend,
  att.global.rendition.attribute.style,
  att.global.rendition.attribute.rendition
att.global.rendition.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list { data.word+ }
  }?
att.global.rendition.attribute.style =
  
  ## contains an expression in some formal style definition language which defines the rendering or presentation used for this element in the source text
  attribute style { data.text }?
att.global.rendition.attribute.rendition =
  
  ## points to a description of the rendering or presentation used for this element in the source text.
  attribute rendition {
    list { data.pointer+ }
  }?
att.global.attributes =
  att.global.rendition.attributes,
  att.global.responsibility.attributes,
  att.global.attribute.xmlid,
  att.global.attribute.n,
  att.global.attribute.xmllang,
  att.global.attribute.xmlbase,
  att.global.attribute.xmlspace
att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.n =
  
  ## (number) gives a number (or other label) for an element, which is not necessarily unique within the document.
  attribute n { data.text }?
att.global.attribute.xmllang =
  
  ## (language) indicates the language of the element content using a tag generated according to BCP 47.
  attribute xml:lang { data.language }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base { data.pointer }?
att.global.attribute.xmlspace =
  
  ## signals an intention about how white space should be managed by applications.
  attribute xml:space {
    
    ## signals that the application's default white-space processing modes are acceptable
    "default"
    | 
      ## indicates the intent that applications preserve all white space
      "preserve"
  }?
att.handFeatures.attributes =
  att.handFeatures.attribute.scribe,
  att.handFeatures.attribute.scribeRef,
  att.handFeatures.attribute.script,
  att.handFeatures.attribute.scriptRef,
  att.handFeatures.attribute.medium,
  att.handFeatures.attribute.scope
att.handFeatures.attribute.scribe =
  
  ## gives a name or other identifier for the scribe believed to be responsible for this hand.
  attribute scribe { data.name }?
att.handFeatures.attribute.scribeRef =
  
  ## points to a full description of the scribe concerned, typically supplied by a person element elsewhere in the description.
  attribute scribeRef {
    list { data.pointer+ }
  }?
att.handFeatures.attribute.script =
  
  ## characterizes the particular script or writing style used by this hand, for example secretary, copperplate, Chancery, Italian, etc.
  attribute script {
    list { data.name+ }
  }?
att.handFeatures.attribute.scriptRef =
  
  ## points to a full description of the script or writing style used by this hand, typically supplied by a scriptNote element elsewhere in the description.
  attribute scriptRef {
    list { data.pointer+ }
  }?
att.handFeatures.attribute.medium =
  
  ## describes the tint or type of ink, e.g. brown, or other writing medium, e.g. pencil
  attribute medium {
    list { data.enumerated+ }
  }?
att.handFeatures.attribute.scope =
  
  ## specifies how widely this hand is used in the manuscript.
  attribute scope {
    
    ## only this hand is used throughout the manuscript
    "sole"
    | 
      ## this hand is used through most of the manuscript
      "major"
    | 
      ## this hand is used occasionally in the manuscript
      "minor"
  }?
att.internetMedia.attributes = att.internetMedia.attribute.mimeType
att.internetMedia.attribute.mimeType =
  
  ## (MIME media type) specifies the applicable multimedia internet mail extension (MIME) media type
  attribute mimeType {
    list { data.word+ }
  }?
att.naming.attributes = att.canonical.attributes
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## specifies where this item is placed
  ## Suggested values include: 1] below; 2] bottom; 3] margin; 4] top; 5] opposite; 6] overleaf; 7] above; 8] end; 9] inline; 10] inspace
  attribute place {
    list {
      (
       ## below the line
       "below"
       | 
         ## at the foot of the page
         "bottom"
       | 
         ## in the margin (left, right, or both)
         "margin"
       | 
         ## at the top of the page
         "top"
       | 
         ## on the opposite, i.e. facing, page
         "opposite"
       | 
         ## on the other side of the leaf
         "overleaf"
       | 
         ## above the line
         "above"
       | 
         ## at the end of e.g. chapter or volume.
         "end"
       | 
         ## within the body of the text.
         "inline"
       | 
         ## in a predefined space, for example left by an earlier scribe.
         "inspace"
       | xsd:Name)+
    }
  }?
sch:pattern [
  id = "oddbyexample-att.typed-subtypeTyped-constraint-1"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "*[@subtype]"
    "\x{a}" ~
    "        "
    sch:assert [
      test = "@type"
      "The "
      sch:name [ ]
      " element should not be categorized in detail with @subtype\x{a}" ~
      " unless also categorized in general with @type"
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
att.pointing.attributes =
  att.pointing.attribute.targetLang,
  att.pointing.attribute.target,
  att.pointing.attribute.evaluate
att.pointing.attribute.targetLang =
  
  ## specifies the language of the content to be found at the destination referenced by target, using a language tag generated according to BCP 47.
  attribute targetLang { data.language }?
sch:pattern [
  id = "oddbyexample-att.pointing-targetLang-targetLang-constraint-2"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[not(self::tei:schemaSpec)][@targetLang]"
    "\x{a}" ~
    "            "
    sch:assert [
      test = "count(@target)"
      "@targetLang can only be used if @target is specified."
    ]
    "\x{a}" ~
    "          "
  ]
  "\x{a}" ~
  "   "
]
att.pointing.attribute.target =
  
  ## specifies the destination of the reference by supplying one or more URI References
  attribute target {
    list { data.pointer+ }
  }?
att.pointing.attribute.evaluate =
  
  ## specifies the intended meaning when the target of a pointer is itself a pointer.
  attribute evaluate {
    
    ## if the element pointed to is itself a pointer, then the target of that pointer will be taken, and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## if the element pointed to is itself a pointer, then its target (whether a pointer or not) is taken as the target of this pointer.
      "one"
    | 
      ## no further evaluation of targets is carried out beyond that needed to find the element specified in the pointer's target.
      "none"
  }?
att.sortable.attributes = att.sortable.attribute.sortKey
att.sortable.attribute.sortKey =
  
  ## supplies the sort key for this element in an index, list or group which contains it.
  attribute sortKey { data.word }?
model.nameLike.agent = name
model.nameLike.agent_alternation = name
model.nameLike.agent_sequence = name
model.nameLike.agent_sequenceOptional = name?
model.nameLike.agent_sequenceOptionalRepeatable = name*
model.nameLike.agent_sequenceRepeatable = name+
model.segLike = notAllowed
model.hiLike = notAllowed
model.hiLike_alternation = notAllowed
model.hiLike_sequence = empty
model.hiLike_sequenceOptional = empty
model.hiLike_sequenceOptionalRepeatable = empty
model.hiLike_sequenceRepeatable = notAllowed
model.emphLike = title
model.emphLike_alternation = title
model.emphLike_sequence = title
model.emphLike_sequenceOptional = title?
model.emphLike_sequenceOptionalRepeatable = title*
model.emphLike_sequenceRepeatable = title+
model.highlighted = model.hiLike | model.emphLike
model.dateLike = date
model.dateLike_alternation = date
model.dateLike_sequence = date
model.dateLike_sequenceOptional = date?
model.dateLike_sequenceOptionalRepeatable = date*
model.dateLike_sequenceRepeatable = date+
model.measureLike = height | width
model.measureLike_alternation = height | width
model.measureLike_sequence = height, width
model.measureLike_sequenceOptional = height?, width?
model.measureLike_sequenceOptionalRepeatable = height*, width*
model.measureLike_sequenceRepeatable = height+, width+
model.egLike = notAllowed
model.egLike_alternation = notAllowed
model.egLike_sequence = empty
model.egLike_sequenceOptional = empty
model.egLike_sequenceOptionalRepeatable = empty
model.egLike_sequenceRepeatable = notAllowed
model.graphicLike = notAllowed
model.offsetLike = notAllowed
model.offsetLike_alternation = notAllowed
model.offsetLike_sequence = empty
model.offsetLike_sequenceOptional = empty
model.offsetLike_sequenceOptionalRepeatable = empty
model.offsetLike_sequenceRepeatable = notAllowed
model.pPart.msdesc = locus | origDate
model.pPart.editorial = notAllowed
model.pPart.editorial_alternation = notAllowed
model.pPart.editorial_sequence = empty
model.pPart.editorial_sequenceOptional = empty
model.pPart.editorial_sequenceOptionalRepeatable = empty
model.pPart.editorial_sequenceRepeatable = notAllowed
model.pPart.transcriptional = notAllowed
model.pPart.transcriptional_alternation = notAllowed
model.pPart.transcriptional_sequence = empty
model.pPart.transcriptional_sequenceOptional = empty
model.pPart.transcriptional_sequenceOptionalRepeatable = empty
model.pPart.transcriptional_sequenceRepeatable = notAllowed
model.pPart.edit = model.pPart.editorial | model.pPart.transcriptional
model.ptrLike = ref
model.lPart = notAllowed
model.global.meta = notAllowed
model.milestoneLike = notAllowed
model.gLike = notAllowed
model.oddDecl = notAllowed
model.oddDecl_alternation = notAllowed
model.oddDecl_sequence = empty
model.oddDecl_sequenceOptional = empty
model.oddDecl_sequenceOptionalRepeatable = empty
model.oddDecl_sequenceRepeatable = notAllowed
model.phrase.xml = notAllowed
model.specDescLike = notAllowed
model.biblLike = bibl | listBibl | msDesc
model.biblLike_alternation = bibl | listBibl | msDesc
model.biblLike_sequence = bibl, listBibl, msDesc
model.biblLike_sequenceOptional = bibl?, listBibl?, msDesc?
model.biblLike_sequenceOptionalRepeatable = bibl*, listBibl*, msDesc*
model.biblLike_sequenceRepeatable = bibl+, listBibl+, msDesc+
model.headLike = head
model.headLike_alternation = head
model.headLike_sequence = head
model.headLike_sequenceOptional = head?
model.headLike_sequenceOptionalRepeatable = head*
model.headLike_sequenceRepeatable = head+
model.labelLike = notAllowed
model.labelLike_alternation = notAllowed
model.labelLike_sequence = empty
model.labelLike_sequenceOptional = empty
model.labelLike_sequenceOptionalRepeatable = empty
model.labelLike_sequenceRepeatable = notAllowed
model.listLike = notAllowed
model.listLike_alternation = notAllowed
model.listLike_sequence = empty
model.listLike_sequenceOptional = empty
model.listLike_sequenceOptionalRepeatable = empty
model.listLike_sequenceRepeatable = notAllowed
model.noteLike = note
model.lLike = l
model.lLike_alternation = l
model.lLike_sequence = l
model.lLike_sequenceOptional = l?
model.lLike_sequenceOptionalRepeatable = l*
model.lLike_sequenceRepeatable = l+
model.pLike = p
model.pLike_alternation = p
model.pLike_sequence = p
model.pLike_sequenceOptional = p?
model.pLike_sequenceOptionalRepeatable = p*
model.pLike_sequenceRepeatable = p+
model.stageLike = notAllowed
model.stageLike_alternation = notAllowed
model.stageLike_sequence = empty
model.stageLike_sequenceOptional = empty
model.stageLike_sequenceOptionalRepeatable = empty
model.stageLike_sequenceRepeatable = notAllowed
model.global.edit = notAllowed
model.divPart = model.lLike | model.pLike | lg
model.placeNamePart = country | settlement
model.placeNamePart_alternation = country | settlement
model.placeNamePart_sequence = country, settlement
model.placeNamePart_sequenceOptional = country?, settlement?
model.placeNamePart_sequenceOptionalRepeatable = country*, settlement*
model.placeNamePart_sequenceRepeatable = country+, settlement+
model.placeStateLike = model.placeNamePart
model.placeStateLike_alternation = model.placeNamePart_alternation
model.placeStateLike_sequence = model.placeNamePart_sequence
model.placeStateLike_sequenceOptional =
  model.placeNamePart_sequenceOptional?
model.placeStateLike_sequenceOptionalRepeatable =
  model.placeNamePart_sequenceOptionalRepeatable*
model.placeStateLike_sequenceRepeatable =
  model.placeNamePart_sequenceRepeatable+
model.publicationStmtPart.agency = publisher
model.publicationStmtPart.detail = date | pubPlace | idno
model.quoteLike = notAllowed
model.quoteLike_alternation = notAllowed
model.quoteLike_sequence = empty
model.quoteLike_sequenceOptional = empty
model.quoteLike_sequenceOptionalRepeatable = empty
model.quoteLike_sequenceRepeatable = notAllowed
model.qLike = model.quoteLike
model.qLike_alternation = model.quoteLike_alternation
model.qLike_sequence = model.quoteLike_sequence
model.qLike_sequenceOptional = model.quoteLike_sequenceOptional?
model.qLike_sequenceOptionalRepeatable =
  model.quoteLike_sequenceOptionalRepeatable*
model.qLike_sequenceRepeatable = model.quoteLike_sequenceRepeatable+
model.respLike = author
model.divWrapper = notAllowed
model.divTopPart = model.headLike
model.divTop = model.divWrapper | model.divTopPart
model.divBottomPart = notAllowed
model.divBottom = model.divWrapper | model.divBottomPart
model.imprintPart = publisher | pubPlace
model.addressLike = notAllowed
model.addressLike_alternation = notAllowed
model.addressLike_sequence = empty
model.addressLike_sequenceOptional = empty
model.addressLike_sequenceOptionalRepeatable = empty
model.addressLike_sequenceRepeatable = notAllowed
model.nameLike =
  model.nameLike.agent
  | model.offsetLike
  | model.placeStateLike
  | idno
  | model.persNamePart
model.nameLike_alternation =
  model.nameLike.agent_alternation
  | model.offsetLike_alternation
  | model.placeStateLike_alternation
  | idno
  | model.persNamePart_alternation
model.nameLike_sequence =
  model.nameLike.agent_sequence,
  model.offsetLike_sequence,
  model.placeStateLike_sequence,
  idno,
  model.persNamePart_sequence
model.nameLike_sequenceOptional =
  model.nameLike.agent_sequenceOptional?,
  model.offsetLike_sequenceOptional?,
  model.placeStateLike_sequenceOptional?,
  idno?,
  model.persNamePart_sequenceOptional?
model.nameLike_sequenceOptionalRepeatable =
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.offsetLike_sequenceOptionalRepeatable*,
  model.placeStateLike_sequenceOptionalRepeatable*,
  idno*,
  model.persNamePart_sequenceOptionalRepeatable*
model.nameLike_sequenceRepeatable =
  model.nameLike.agent_sequenceRepeatable+,
  model.offsetLike_sequenceRepeatable+,
  model.placeStateLike_sequenceRepeatable+,
  idno+,
  model.persNamePart_sequenceRepeatable+
model.global =
  model.global.meta
  | model.milestoneLike
  | model.noteLike
  | model.global.edit
model.biblPart =
  model.respLike | model.imprintPart | bibl | msIdentifier | extent
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.inter =
  model.egLike
  | model.oddDecl
  | model.biblLike
  | model.labelLike
  | model.listLike
  | model.stageLike
  | model.qLike
model.common = model.divPart | model.inter | model.entryLike
model.phrase =
  model.segLike
  | model.highlighted
  | model.graphicLike
  | model.pPart.msdesc
  | model.pPart.edit
  | model.ptrLike
  | model.lPart
  | model.phrase.xml
  | model.specDescLike
  | model.pPart.data
  | model.ptrLike.form
model.divLike = notAllowed
model.divGenLike = notAllowed
model.div1Like = notAllowed
model.teiHeaderPart = notAllowed
model.sourceDescPart = notAllowed
att.source.attributes = att.source.attribute.source
att.source.attribute.source =
  
  ## provides a pointer to the bibliographical source from which a quotation or citation is drawn.
  attribute source {
    list { data.pointer+ }
  }?
model.resourceLike = notAllowed
att.personal.attributes = att.naming.attributes
p =
  
  ## (paragraph) marks paragraphs in prose. [3.1. Paragraphs 7.2.5. Speech Contents]
  element p {
    macro.paraContent,
    att.global.attributes,
    att.declaring.attributes,
    att.fragmentable.attributes,
    empty
  }
name =
  
  ## (name, proper noun) contains a proper noun or noun phrase. [3.5.1. Referring Strings]
  element name {
    macro.phraseSeq,
    att.global.attributes,
    att.personal.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    att.editLike.attributes,
    empty
  }
date =
  
  ## contains a date in any format. [3.5.4. Dates and Times 2.2.4. Publication, Distribution,
  ## Licensing, etc. 2.5. The Revision Description 3.11.2.4. Imprint, Size of a Document, and Reprint Information 15.2.3. The Setting Description 13.3.6. Dates and Times]
  element date {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    att.editLike.attribute.evidence,
    att.editLike.attribute.instant,
    att.ranging.attribute.atLeast,
    att.ranging.attribute.atMost,
    att.ranging.attribute.min,
    att.ranging.attribute.max,
    att.ranging.attribute.confidence,
    att.source.attribute.source,
    empty
  }
ref =
  
  ## (reference) defines a reference to another location, possibly modified by additional text or comment. [3.6. Simple Links and Cross-References 16.1. Links]
  element ref {
    macro.paraContent
    >> sch:pattern [
         id = "oddbyexample-ref-refAtts-constraint-1"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:ref"
           "\x{a}" ~
           "               "
           sch:report [
             test = "@target and @cRef"
             "Only one of the\x{a}" ~
             "	attributes @target' and @cRef' may be supplied on "
             sch:name [ ]
             "\x{a}" ~
             "               "
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.pointing.attributes,
    att.internetMedia.attributes,
    att.declaring.attributes,
    att.cReferencing.attributes,
    empty
  }
head =
  
  ## (heading) contains any type of heading, for example the title of a section, or the heading of a list, glossary, manuscript description, etc. [4.2.1. Headings and Trailers]
  element head {
    (text
     | lg
     | model.gLike
     | model.phrase
     | model.inter
     | model.lLike
     | model.global)*,
    att.global.attributes,
    empty
  }
note =
  
  ## contains a note or annotation. [3.8.1. Notes and Simple Annotation 2.2.6. The Notes Statement 3.11.2.8. Notes and Statement of Language 9.3.5.4. Notes within Entries]
  element note {
    macro.specialPara,
    att.global.attributes,
    att.placement.attributes,
    att.pointing.attributes,
    att.source.attributes,
    empty
  }
author =
  
  ## in a bibliographic reference, contains the name(s) of an author, personal or corporate, of a work; for example in the same form as that provided by a recognized bibliographic name authority. [3.11.2.2. Titles, Authors, and Editors 2.2.1. The Title Statement]
  element author {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
title =
  
  ## contains a title for any kind of work. [3.11.2.2. Titles, Authors, and Editors 2.2.1. The Title Statement 2.2.5. The Series Statement]
  element title {
    macro.paraContent,
    att.global.attributes,
    att.canonical.attributes,
    empty
  }
publisher =
  
  ## provides the name of the organization responsible for the publication or distribution of a bibliographic item. [3.11.2.4. Imprint, Size of a Document, and Reprint Information 2.2.4. Publication, Distribution,
  ## Licensing, etc.]
  element publisher { macro.phraseSeq, att.global.attributes, empty }
pubPlace =
  
  ## (publication place) contains the name of the place where a bibliographic item was published. [3.11.2.4. Imprint, Size of a Document, and Reprint Information]
  element pubPlace {
    macro.phraseSeq, att.global.attributes, att.naming.attributes, empty
  }
bibl =
  
  ## (bibliographic citation) contains a loosely-structured bibliographic citation of which the sub-components may or may not be explicitly tagged. [3.11.1. Methods of Encoding Bibliographic References and Lists of References 2.2.7. The Source Description 15.3.2. Declarable Elements]
  element bibl {
    (text
     | model.gLike
     | model.highlighted
     | model.pPart.data
     | model.pPart.edit
     | model.segLike
     | model.ptrLike
     | model.biblPart
     | model.global)*,
    att.global.attributes,
    att.declarable.attributes,
    att.sortable.attributes,
    att.docStatus.attributes,
    empty
  }
listBibl =
  
  ## (citation list) contains a list of bibliographic citations of any kind. [3.11.1. Methods of Encoding Bibliographic References and Lists of References 2.2.7. The Source Description 15.3.2. Declarable Elements]
  element listBibl {
    (model.headLike*, (model.biblLike | model.milestoneLike)+, empty*),
    att.global.attributes,
    att.sortable.attributes,
    att.declarable.attributes,
    empty
  }
l =
  
  ## (verse line) contains a single, possibly incomplete, line of verse. [3.12.1. Core Tags for Verse 3.12. Passages of Verse or Drama 7.2.5. Speech Contents]
  element l {
    macro.paraContent,
    att.global.attributes,
    att.fragmentable.attributes,
    empty
  }
lg =
  
  ## (line group) contains one or more verse lines functioning as a formal unit, e.g. a stanza, refrain, verse paragraph, etc. [3.12.1. Core Tags for Verse 3.12. Passages of Verse or Drama 7.2.5. Speech Contents]
  element lg {
    ((model.divTop | model.global)*,
     (model.lLike | model.stageLike | model.labelLike | lg),
     (model.lLike
      | model.stageLike
      | model.labelLike
      | model.global
      | lg)*,
     (model.divBottom, model.global*)*)
    >> sch:pattern [
         id = "oddbyexample-lg-atleast1oflggapl-constraint-3"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:lg"
           "\x{a}" ~
           "               "
           sch:assert [
             test =
               "count(descendant::tei:lg|descendant::tei:l|descendant::tei:gap) > 0"
             "An lg element\x{a}" ~
             "        must contain at least one child l, lg or gap element."
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    att.divLike.attributes,
    att.declaring.attributes,
    
    ## characterizes the element in some sense, using any convenient classification scheme or typology.
    attribute type {
      
      ##
      "quatrain"
      | 
        ##
        "sizain"
      | 
        ##
        "sonnet"
      | 
        ##
        "tercet"
    }?,
    empty
  }
att.msExcerpt.attributes = att.msExcerpt.attribute.defective
att.msExcerpt.attribute.defective =
  
  ## indicates whether the passage being quoted is defective, i.e. incomplete through loss or damage.
  [ a:defaultValue = "false" ] attribute defective { data.xTruthValue }?
msDesc =
  
  ## (manuscript description) contains a description of a single identifiable manuscript or other text-bearing object. [10.1. Overview]
  element msDesc {
    (msIdentifier,
     model.headLike*,
     (model.pLike+ | (msContents?, physDesc?, history?))),
    att.global.attributes,
    att.sortable.attributes,
    att.declaring.attributes,
    empty
  }
height =
  
  ## contains a measurement measured along the axis at right angles to the bottom of the written surface, i.e. parallel to the spine for a codex or book. [10.3.4. Dimensions]
  element height {
    macro.xtext, att.global.attributes, att.dimensions.attributes, empty
  }
width =
  
  ## contains a measurement measured along the axis parallel to the bottom of the written surface, i.e. perpendicular to the spine of a book or codex. [10.3.4. Dimensions]
  element width {
    macro.xtext, att.global.attributes, att.dimensions.attributes, empty
  }
locus =
  
  ## defines a location within a manuscript or manuscript part, usually as a (possibly discontinuous) sequence of folio references. [10.3.5. References to Locations within a Manuscript]
  element locus {
    macro.xtext, att.global.attributes, att.pointing.attributes, empty
  }
origDate =
  
  ## (origin date) contains any form of date, used to identify the date of origin for a manuscript or manuscript part. [10.3.1. Origination]
  element origDate {
    (text | model.gLike | model.phrase | model.global)*,
    att.global.attributes,
    att.datable.attributes,
    att.editLike.attribute.evidence,
    att.editLike.attribute.instant,
    att.ranging.attribute.atLeast,
    att.ranging.attribute.atMost,
    att.ranging.attribute.min,
    att.ranging.attribute.max,
    att.ranging.attribute.confidence,
    att.source.attribute.source,
    empty
  }
msIdentifier =
  
  ## (manuscript identifier) contains the information required to identify the manuscript being described. [10.4. The Manuscript Identifier]
  element msIdentifier {
    ((model.placeNamePart_sequenceOptional, idno?), (altIdentifier)*)
    >> sch:pattern [
         id = "oddbyexample-msIdentifier-msId_minimal-constraint-2"
         "\x{a}" ~
         "            "
         sch:rule [
           context = "tei:msIdentifier"
           "\x{a}" ~
           "               "
           sch:report [
             test =
               "not(parent::tei:msPart) and       (local-name(*[1])='idno' or       local-name(*[1])='altIdentifier' or       normalize-space(.)='')"
             "An msIdentifier must contain either a repository or location of some type, or a manuscript name"
           ]
           "\x{a}" ~
           "            "
         ]
         "\x{a}" ~
         "         "
       ],
    att.global.attributes,
    empty
  }
altIdentifier =
  
  ## (alternative identifier) contains an alternative or former structured identifier used for a manuscript, such as a former catalogue number. [10.4. The Manuscript Identifier]
  element altIdentifier {
    (model.placeNamePart_sequenceOptional, idno, note?),
    att.global.attributes,
    empty
  }
explicit =
  
  ## contains the explicit of a manuscript item, that is, the closing words of the text proper, exclusive of any rubric or colophon which might follow it. [10.6.1. The msItem and msItemStruct Elements]
  element explicit {
    macro.phraseSeq,
    att.global.attributes,
    att.msExcerpt.attributes,
    empty
  }
incipit =
  
  ## contains the incipit of a manuscript item, that is the opening words of the text proper, exclusive of any rubric which might precede it, of sufficient length to identify the work uniquely; such incipits were, in former times, frequently used a means of reference to a work, in place of a title. [10.6.1. The msItem and msItemStruct Elements]
  element incipit {
    macro.phraseSeq,
    att.global.attributes,
    att.msExcerpt.attributes,
    empty
  }
msContents =
  
  ## (manuscript contents) describes the intellectual content of a manuscript or manuscript part, either as a series of paragraphs or as a series of structured manuscript items. [10.6. Intellectual Content]
  element msContents {
    (model.pLike+ | (msItemStruct)*),
    att.global.attributes,
    att.msExcerpt.attributes,
    
    ## identifies the text types or classifications applicable to this object by pointing to other elements or resources defining the classification concerned. 
    attribute class {
      list { data.pointer+ }
    }?,
    empty
  }
msItemStruct =
  
  ## (structured manuscript item) contains a structured description for an individual work or item within the intellectual content of a manuscript or manuscript part. [10.6.1. The msItem and msItemStruct Elements]
  element msItemStruct {
    ((locus)?,
     (model.pLike+
      | (author*,
         title*,
         incipit?,
         msItemStruct*,
         explicit?,
         listBibl*,
         (bibl)*,
         model.noteLike*))),
    att.global.attributes,
    att.msExcerpt.attributes,
    
    ## identifies the text types or classifications applicable to this item by pointing to other elements or resources defining the classification concerned.
    attribute class {
      list { data.pointer+ }
    }?,
    empty
  }
physDesc =
  
  ## (physical description) contains a full physical description of a manuscript or manuscript part, optionally subdivided using more specialized elements from the model.physDescPart class. [10.7. Physical Description]
  element physDesc {
    (model.pLike*, model.physDescPart_sequenceOptional),
    att.global.attributes,
    empty
  }
objectDesc =
  
  ## contains a description of the physical components making up the object which is being described. [10.7.1. Object Description]
  element objectDesc {
    (model.pLike+ | (supportDesc?, layoutDesc?)),
    att.global.attributes,
    empty
  }
supportDesc =
  
  ## (support description) groups elements describing the physical support for the written part of a manuscript. [10.7.1. Object Description]
  element supportDesc {
    (model.pLike+ | (support?, extent?, foliation*)),
    att.global.attributes,
    empty
  }
support =
  
  ## contains a description of the materials etc. which make up the physical support for the written part of a manuscript. [10.7.1. Object Description]
  element support { macro.specialPara, att.global.attributes, empty }
foliation =
  
  ## describes the numbering system or systems used to count the leaves or pages in a codex. [10.7.1.4. Foliation]
  element foliation { macro.specialPara, att.global.attributes, empty }
layoutDesc =
  
  ## (layout description) collects the set of layout descriptions applicable to a manuscript. [10.7.2. Writing, Decoration, and Other Notations]
  element layoutDesc {
    (model.pLike+ | layout+), att.global.attributes, empty
  }
layout =
  
  ## describes how text is laid out on the page, including information about any ruling, pricking, or other evidence of page-preparation techniques. [10.7.2. Writing, Decoration, and Other Notations]
  element layout {
    macro.specialPara,
    att.global.attributes,
    
    ## specifies the number of columns per page
    attribute columns {
      list { data.count, data.count? }
    }?,
    empty
  }
scriptDesc =
  
  ## contains a description of the scripts used in a manuscript or similar source. [10.7.2.1. Writing]
  element scriptDesc {
    (model.pLike+ | scriptNote+), att.global.attributes, empty
  }
history =
  
  ## groups elements describing the full history of a manuscript or manuscript part. [10.8. History]
  element history {
    (model.pLike+ | (origin?, provenance*)),
    att.global.attributes,
    empty
  }
origin =
  
  ## contains any descriptive or other information concerning the origin of a manuscript or manuscript part. [10.8. History]
  element origin {
    macro.specialPara,
    att.global.attributes,
    att.editLike.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    empty
  }
provenance =
  
  ## contains any descriptive or other information concerning a single identifiable episode during the history of a manuscript or manuscript part, after its creation but before its acquisition. [10.8. History]
  element provenance {
    macro.specialPara,
    att.global.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    att.source.attributes,
    empty
  }
att.datable.custom.attributes =
  att.datable.custom.attribute.when-custom,
  att.datable.custom.attribute.notBefore-custom,
  att.datable.custom.attribute.notAfter-custom,
  att.datable.custom.attribute.from-custom,
  att.datable.custom.attribute.to-custom,
  att.datable.custom.attribute.datingPoint,
  att.datable.custom.attribute.datingMethod
att.datable.custom.attribute.when-custom =
  
  ## supplies the value of a date or time in some custom standard form.
  attribute when-custom {
    list { data.word+ }
  }?
att.datable.custom.attribute.notBefore-custom =
  
  ## specifies the earliest possible date for the event in some custom standard form.
  attribute notBefore-custom {
    list { data.word+ }
  }?
att.datable.custom.attribute.notAfter-custom =
  
  ## specifies the latest possible date for the event in some custom standard form.
  attribute notAfter-custom {
    list { data.word+ }
  }?
att.datable.custom.attribute.from-custom =
  
  ## indicates the starting point of the period in some custom standard form.
  attribute from-custom {
    list { data.word+ }
  }?
att.datable.custom.attribute.to-custom =
  
  ## indicates the ending point of the period in some custom standard form.
  attribute to-custom {
    list { data.word+ }
  }?
att.datable.custom.attribute.datingPoint =
  
  ## supplies a pointer to some location defining a named point in time with reference to which the datable item is understood to have occurred
  attribute datingPoint { data.pointer }?
att.datable.custom.attribute.datingMethod =
  
  ## supplies a pointer to a calendar element or other means of interpreting the values of the custom dating attributes.
  attribute datingMethod { data.pointer }?
att.datable.iso.attributes =
  att.datable.iso.attribute.when-iso,
  att.datable.iso.attribute.notBefore-iso,
  att.datable.iso.attribute.notAfter-iso,
  att.datable.iso.attribute.from-iso,
  att.datable.iso.attribute.to-iso
att.datable.iso.attribute.when-iso =
  
  ## supplies the value of a date or time in a standard form.
  attribute when-iso { data.temporal.iso }?
att.datable.iso.attribute.notBefore-iso =
  
  ## specifies the earliest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notBefore-iso { data.temporal.iso }?
att.datable.iso.attribute.notAfter-iso =
  
  ## specifies the latest possible date for the event in standard form, e.g. yyyy-mm-dd.
  attribute notAfter-iso { data.temporal.iso }?
att.datable.iso.attribute.from-iso =
  
  ## indicates the starting point of the period in standard form.
  attribute from-iso { data.temporal.iso }?
att.datable.iso.attribute.to-iso =
  
  ## indicates the ending point of the period in standard form.
  attribute to-iso { data.temporal.iso }?
forename =
  
  ## contains a forename, given or baptismal name. [13.2.1. Personal Names]
  element forename {
    macro.phraseSeq,
    att.global.attributes,
    att.personal.attributes,
    empty
  }
country =
  
  ## contains the name of a geo-political unit, such as a nation, country, colony, or commonwealth, larger than or administratively superior to a region and smaller than a bloc. [13.2.3. Place Names]
  element country {
    macro.phraseSeq,
    att.global.attributes,
    att.naming.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    empty
  }
settlement =
  
  ## contains the name of a settlement such as a city, town, or village identified as a single geo-political or administrative unit. [13.2.3. Place Names]
  element settlement {
    macro.phraseSeq,
    att.global.attributes,
    att.naming.attributes,
    att.datable.iso.attribute.when-iso,
    att.datable.iso.attribute.notBefore-iso,
    att.datable.iso.attribute.notAfter-iso,
    att.datable.iso.attribute.from-iso,
    att.datable.iso.attribute.to-iso,
    att.datable.custom.attribute.when-custom,
    att.datable.custom.attribute.notBefore-custom,
    att.datable.custom.attribute.notAfter-custom,
    att.datable.custom.attribute.from-custom,
    att.datable.custom.attribute.to-custom,
    att.datable.custom.attribute.datingPoint,
    att.datable.custom.attribute.datingMethod,
    empty
  }
teiHeader =
  
  ## (TEI header) supplies the descriptive and declarative information making up an electronic title page for every TEI-conformant document. [2.1.1. The TEI Header and Its Components 15.1. Varieties of Composite Text]
  element teiHeader {
    (fileDesc, model.teiHeaderPart*),
    att.global.attributes,
    
    ## specifies the kind of document to which the header is attached, for example whether it is a corpus or individual text.
    ## Sample values include: 1] text; 2] corpus
    [ a:defaultValue = "text" ] attribute type { data.enumerated }?,
    empty
  }
fileDesc =
  
  ## (file description) contains a full bibliographic description of an electronic file. [2.2. The File Description 2.1.1. The TEI Header and Its Components]
  element fileDesc {
    ((titleStmt, extent?, publicationStmt), sourceDesc+),
    att.global.attributes,
    empty
  }
titleStmt =
  
  ## (title statement) groups information about the title of a work and those responsible for its content. [2.2.1. The Title Statement 2.2. The File Description]
  element titleStmt {
    (title+, model.respLike*), att.global.attributes, empty
  }
extent =
  
  ## describes the approximate size of a text stored on some carrier medium or of some other object, digital or non-digital, specified in any convenient units. [2.2.3. Type and Extent of File 2.2. The File Description 3.11.2.4. Imprint, Size of a Document, and Reprint Information 10.7.1. Object Description]
  element extent { macro.phraseSeq, att.global.attributes, empty }
publicationStmt =
  
  ## (publication statement) groups information concerning the publication or distribution of an electronic or other text. [2.2.4. Publication, Distribution,
  ## Licensing, etc. 2.2. The File Description]
  element publicationStmt {
    ((model.publicationStmtPart.agency,
      model.publicationStmtPart.detail*)+
     | model.pLike+),
    att.global.attributes,
    empty
  }
idno =
  
  ## (identifier) supplies any form of identifier used to identify some object, such as a bibliographic item, a person, a title, an organization, etc. in a standardized way. [2.2.4. Publication, Distribution,
  ## Licensing, etc. 2.2.5. The Series Statement 3.11.2.4. Imprint, Size of a Document, and Reprint Information]
  element idno {
    (text | model.gLike | idno)*,
    att.global.attributes,
    att.sortable.attributes,
    empty
  }
sourceDesc =
  
  ## (source description) describes the source from which an electronic text was derived or generated, typically a bibliographic description in the case of a digitized text, or a phrase such as "born digital" for a text which has no previous existence. [2.2.7. The Source Description]
  element sourceDesc {
    (model.pLike+
     | (model.biblLike | model.sourceDescPart | model.listLike)+),
    att.global.attributes,
    att.declarable.attributes,
    empty
  }
scriptNote =
  
  ## describes a particular script distinguished within the description of a manuscript or similar resource. [10.7.2. Writing, Decoration, and Other Notations]
  element scriptNote {
    macro.specialPara,
    att.global.attributes,
    att.handFeatures.attributes,
    empty
  }
TEI =
  
  ## (TEI document) contains a single TEI-conformant document, containing a single TEI header, a single text, one or more members of the model.resourceLike class, or a combination of these. A series of TEI elements may be combined together to form a teiCorpus element. [4. Default Text Structure 15.1. Varieties of Composite Text]
  element TEI {
    (teiHeader,
     ((model.resourceLike+, \text?) | \text))
    >> sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
    >> sch:ns [ prefix = "xs" uri = "http://www.w3.org/2001/XMLSchema" ]
    >> sch:ns [
         prefix = "rng"
         uri = "http://relaxng.org/ns/structure/1.0"
       ],
    att.global.attributes,
    empty
  }
\text =
  
  ## contains a single text of any kind, whether unitary or composite, for example a poem or drama, a collection of essays, a novel, a dictionary, or a corpus sample. [4. Default Text Structure 15.1. Varieties of Composite Text]
  element text {
    (model.global*, (body), model.global*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
body =
  
  ## (text body) contains the whole body of a single unitary text, excluding any front or back matter. [4. Default Text Structure]
  element body {
    (model.global*,
     (model.divTop, (model.global | model.divTop)*)?,
     (model.divGenLike, (model.global | model.divGenLike)*)?,
     ((model.divLike, (model.global | model.divGenLike)*)+
      | (model.div1Like, (model.global | model.divGenLike)*)+
      | ((model.common, model.global*)+,
         ((model.divLike, (model.global | model.divGenLike)*)+
          | (model.div1Like, (model.global | model.divGenLike)*)+)?)),
     (model.divBottom, model.global*)*),
    att.global.attributes,
    att.declaring.attributes,
    empty
  }
model.physDescPart_sequenceOptional = objectDesc?, scriptDesc?
model.persNamePart = forename
model.persNamePart_alternation = forename
model.persNamePart_sequence = forename
model.persNamePart_sequenceOptional = forename?
model.persNamePart_sequenceOptionalRepeatable = forename*
model.persNamePart_sequenceRepeatable = forename+
model.entryLike = notAllowed
model.ptrLike.form = notAllowed
start = TEI
